\hypertarget{index_intro_sec}{}\section{Introduction}\label{index_intro_sec}
Gateway \hyperlink{classShadow}{Shadow} Controller is primarily the digital twin of the Cloud \hyperlink{classShadow}{Shadow} Controller. Both \hyperlink{classShadow}{Shadow} Controllers are almost identical in terms of workflow barring few features.

Shadows are the prime facia of a Device i.\+e world would not see the device but the shadow as the device and through that it will controlled. A typical shadow contains the most abstracted information of the device that is the properties and their sub-\/properties. Along with these each property in the shadow has two states 1) reported 2) desired. Reported is current value/state of the device whereas Desired is the state which an external body wants to reach at an interval. \hyperlink{classShadow}{Shadow} manages both these states.

Further, a \hyperlink{classShadow}{Shadow} is nothing but a json file which is generated from R\+A\+ML and represents the above mentioned reported and desired state per properties.\hypertarget{index_structure_sec}{}\section{Structure Of Gateway Shadow Controller}\label{index_structure_sec}
The structure of \hyperlink{classShadow}{Shadow} Controller is primarily divided into three high-\/level component classes.

1) \hyperlink{classShadow}{Shadow} Controller\+: This is the main manager and interface class between shadows and the Device Object. shadowcontroller is the class which is representing this interface. 2) \hyperlink{classShadow}{Shadow}\+: This is the \hyperlink{classShadow}{Shadow} class which manages the actual device shadow which, as I mentioned earlier, is a json file. 3) R\+A\+M\+L\+Py\+Binding\+: This is the class which does the conversion from R\+A\+ML to Json object.

Although loosely coupled each of the components are linked with each other through contracts. For example, \hyperlink{classShadow}{Shadow} Controller class has a contract with \hyperlink{classShadow}{Shadow} class but not with R\+A\+M\+L\+Py\+Binding class, however, \hyperlink{classShadow}{Shadow} class and R\+A\+M\+L\+Py\+Binding class for the end J\+S\+ON file which is our actual \hyperlink{classShadow}{Shadow}.

Each structure is laced with exceptions which are pertinent to the structure it is in. Exceptions are raised only when the contract between two components are not fulfilled. Now, it may be origin components\textquotesingle{} responsibility for the failure or the cloud app or mesh app. The origin is notified of this.

Let us Magnify upon each component, beginning with \hyperlink{classShadow}{Shadow} Controller(shadowcontroller) class.

This class does the job of knowing which shadow is the controller of the device. The major components of this class are its functions which are divided into three categories 1) setup 2) searching for \& calling shadow\textquotesingle{}s functions 3) forwarding the calls to the protocol layer.

In Setup, we are talking about configurations. A whole lot of configurations that can be either individual shadow dependent or wholistically. Currently, such configurations are yet to be finalized. Other important part of this section is \hyperlink{classShadow}{Shadow} Creation which happens when a new Device is added. At this juncture, configuration is also pushed. The \hyperlink{classShadow}{Shadow} is saved in a table with key as device\+Id and value as the pointer of \hyperlink{classShadow}{Shadow} itself.

Commands such as set\+Device\+State and get\+Device\+State fall under the second category. In this \hyperlink{classshadowController}{shadow\+Controller} class finds the shadow and calls that shadow\textquotesingle{}s respective functions given the command. If it doesn\textquotesingle{}t find the shadow, such a message is sent back to the originator.

Last section is the call forwarder i.\+e providing the gateway from right side of the equation i.\+e each shadow can use \hyperlink{classshadowController}{shadow\+Controller}\textquotesingle{}s functions such as Send\+Tocloud, Send\+Telemetry\+Data\+C\+C\+A\+PP, Call\+The\+Interface(for device interface).

\hyperlink{classshadowController}{shadow\+Controller} class does it all and doesn\textquotesingle{}t use any threads and doesn\textquotesingle{}t maintain any queue for the commands. It simply forwards requests and their responses. 



Next section is \hyperlink{classShadow}{Shadow} class. This is the central component of the \hyperlink{classShadow}{Shadow} Controller. This class does the following tasks\+:-\/

1) Maintains Json file shadows(updation of values(reported \& desired), updation of files). 2) Finds Delta for the properties. 3) Gives the reported values.

Each shadow does its task independent of other shadows using threads. Each shadow has a thread associated with it. This thread is task based, if it gets the tasks then only it runs otherwise it sleeps i.\+e not running in a continuous loop eating machine cycles.\hypertarget{index_architecture_sec}{}\section{Workflow Of Gateway Shadow Controller.}\label{index_architecture_sec}
If we discuss the set device state through shadow controller workflow is

1) Command comes for device object which forwards to \hyperlink{classShadow}{Shadow} Controller. 2) \hyperlink{classShadow}{Shadow} Controller finds Shadows which will find the Delta given the Job. 3) Suppose Delta is present, now comes the conditions i.\+e workflow related. 